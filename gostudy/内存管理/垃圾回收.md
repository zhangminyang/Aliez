## 垃圾回收

用户程序（Mutator）会通过内存分配器（Allocator）在堆上申请内存，而垃圾收集器（Collector）负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的堆内存空间。


### 标记清扫算法（mark-sweep）

在这个算法中，通过一个标记初始的root区域，以及一个受控堆区。root区域主要是程序运行到当前时刻的栈和全局数据区域。

* 过程：
  
  标记，通过从root区域出发，扫描所有root区域的对象直接或者间接引用到的对象，将这些对象全部加上标记。

  回收，扫描整个堆区，对所有无标记的对象进行回收并将回收的内存加入空闲链表

* 缺点：需要STW（内存单元并不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，转而执行回收程序）

### 并行的垃圾回收

ms算法本质上就是一个树的遍历过程，并行需要实现并行地进行树的非递归遍历

是先STW找到所有的Root对象，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，再次扫描和标记，以免释放使用中的内存。

### 三色标记法

白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

* 过程
  
  * 起初所有对象都是白色。
  * 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
  * 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
  * 重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

缺点：
因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。

本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为*悬挂指针*，即指针没有指向特定类型的合法对象，影响了内存的安全性5，想要并发或者增量地标记对象还是需要使用*屏障技术*。

### 写屏障

我们结合一段用户代码介绍写屏障：

A.Next = B
A.Next = &C{}
三色标记的扫描线程是跟用户线程并发执行的，考虑这种情况：

用户线程执行完 A.Next = B 后，扫描线程把A标记为黑色，B标记为灰色，用户线程执行 A.Next = &C{} ，C是新对象，被标记为白色，由于A已经被扫描，不会重复扫描，所以C不会被标记为灰色，造成了黑色对象指向白色对象的情况，这种三色标记中是不允许的，结果是C被认为是垃圾对象，最终被清扫掉，当访问C时会造成非法内存访问而Panic。

写屏障可以解决这个问题，当对象引用树发生改变时，即对象指向关系发生变化时，将被指向的对象标记为灰色，维护了三色标记的约束：黑色对象不能直接引用白色对象，这避免了使用中的对象被释放。

有写屏障后，用户线程执行 A.Next = &C{} 后，写屏障把C标记为灰色。


### gc的时机

垃圾回收的触发是由一个gcpercent的变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如，gcpercent=100，当前使用了4M的内存，
那么当内存分配到达8M时就会再次gc。如果回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回
收频率越高，这个算法使得垃圾回收的频率比较稳定，适合应用的场景。
gcpercent的值是通过环境变量GOGC获取的，如果不设置这个环境变量，默认值是100。如果将它设置成off，则是关闭垃圾回收

