## 垃圾回收

### 标记清扫算法（mark-sweep）

在这个算法中，通过一个标记初始的root区域，以及一个受控堆区。root区域主要是程序运行到当前时刻的栈和全局数据区域。

* 过程：
  
  标记，通过从root区域出发，扫描所有root区域的对象直接或者间接引用到的对象，将这些对象全部加上标记。

  回收，扫描整个堆区，对所有无标记的对象进行回收

* 缺点：需要STW（内存单元并不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，转而执行回收程序）

### 并行的垃圾回收

ms算法本质上就是一个树的遍历过程，并行需要实现并行地进行树的非递归遍历

是先STW找到所有的Root对象，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，再次扫描和标记，以免释放使用中的内存。

### 三色标记法

* 过程
  
  * 起初所有对象都是白色。
  * 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
  * 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
  * 重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

### 写屏障

我们结合一段用户代码介绍写屏障：

A.Next = B
A.Next = &C{}
三色标记的扫描线程是跟用户线程并发执行的，考虑这种情况：

用户线程执行完 A.Next = B 后，扫描线程把A标记为黑色，B标记为灰色，用户线程执行 A.Next = &C{} ，C是新对象，被标记为白色，由于A已经被扫描，不会重复扫描，所以C不会被标记为灰色，造成了黑色对象指向白色对象的情况，这种三色标记中是不允许的，结果是C被认为是垃圾对象，最终被清扫掉，当访问C时会造成非法内存访问而Panic。

写屏障可以解决这个问题，当对象引用树发生改变时，即对象指向关系发生变化时，将被指向的对象标记为灰色，维护了三色标记的约束：黑色对象不能直接引用白色对象，这避免了使用中的对象被释放。

有写屏障后，用户线程执行 A.Next = &C{} 后，写屏障把C标记为灰色。


### gc的时机

垃圾回收的触发是由一个gcpercent的变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如，gcpercent=100，当前使用了4M的内存，
那么当内存分配到达8M时就会再次gc。如果回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回
收频率越高，这个算法使得垃圾回收的频率比较稳定，适合应用的场景。
gcpercent的值是通过环境变量GOGC获取的，如果不设置这个环境变量，默认值是100。如果将它设置成off，则是关闭垃圾回收

