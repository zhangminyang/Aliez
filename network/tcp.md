#### 介绍

* 提供面向连接的，可靠的字节流服务
* 为上层应用层提供服务，不关心具体传输的内容。

#### TCP与UDP的区别
* 基于连接和无连接
* 对系统资源的要求（TCP多，UDP少）
* 流模式与数据报模式
* 可靠性与不可靠性
* 顺序性与不保证顺序（系统接受IP数据报的速率超过这些数据报i处理的速率时，系统可能发送ICMP源站抑制差错报文，使用UDP时很容易产生这样的ICMP差错）


#### TCP如何保证可靠性

* 分块传送：数据被分割成最合适的数据块（UDP的数据报长度不变）
* 等待确认：通过定时器等待接收端发送确认请求，收不到确认则重发
* 确认回复：收到确认后发送确认回复(不是立即发送，通常推迟几分之一秒)
* 数据校验：保持首部和数据的校验和，检测数据传输过程有无变化
* 乱序排序：接收端能重排序数据，以正确的顺序交给应用端
* 重复丢弃：接收端能丢弃重复的数据包
* 流量缓冲：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配丢数据

#### 建立 三次握手

客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN

服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）

客户端发送ACK确认收到回复（序列号为服务端序列号+1）



#### 四次挥手

主动关闭的一方发送FIN，表示要单方面关闭数据的传输

服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）

等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输

客户端回复ACK以确认回复

* 为什么要四次挥手

因为tcp协议的半关闭特性，tcp提供了字连接的一端关闭发送之后仍能接收另一端消息的能力，只有第二个FIN确认之后，这个连接才算关闭。

* 为什么要有半关闭？

没有半关闭当客户端需要通知服务端，已经完成了客户端数据传输但是仍然要接收服务端的数据，使用两个tcp连接可以是一个选择，但是采用半关闭会更好。

* 为什么需要TIME_WAIT（2MSL）等待?

每个具体的TCP实现必须选择一个报文段最大生存时间（MSL），它是任何报文段在被丢弃前在网络内存在的最大时间。
当TCP执行一个主动关闭时，最后一个ACK发回的时候，该链接必须在TIME_WAIT时间停留2MSL，这样可以让TCP再发送最后的ACK以防这个ACK丢失。
另一种结果是在这个2MSL时间等待内，定义这个连接的插口不能再被使用，这个连接只能在2MSL后再次被使用。

#### TCP KeepAlive 

基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。