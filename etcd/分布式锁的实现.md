## 概述

锁是在执行多线程时用于强行限制资源访问的同步机制，在分布式系统场景下，为了使多个进程（实例）对共享资源的读写同步，保证数据的最终一致性，而引入了分布式锁。

#### 特点

分布式锁应具备以下特点：

* 互斥性：任意时刻，同一个锁，只有一个进程能持有
* 安全性：避免死锁，当进程没有主动释放锁（进程崩溃退出），保证其他进程能够加锁
* 可用性：当提供锁的服务节点故障（宕机）时，“热备” 节点能够接替故障的节点继续提供服务，并保证自身持有的数据与故障节点一致。
* 对称性：对同一个锁，加锁和解锁必须是同一个进程，即不能把其他进程持有的锁给释放了

重要的是，etcd 支持以下功能，正是依赖这些功能来实现分布式锁的：

* Lease 机制：即租约机制（TTL，Time To Live），Etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除；同时也支持续约，即 KeepAlive。
  
* Revision 机制：每个 key 带有一个 Revision 属性值，etcd 每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。
在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “羊群效应” （也称 “惊群效应”），实现公平锁。

* Prefix 机制：即前缀机制，也称目录机制。可以根据前缀（目录）获取该目录下所有的 key 及对应的属性（包括 key, value 以及 revision 等）。
  
* Watch 机制：即监听机制，Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录（前缀机制），当被 Watch 的 key 或目录发生变化，客户端将收到通知。

## 实现

1.利用租约在etcd集群中创建一个key，这个key有两种形态，存在和不存在，而这两种形态就是互斥量。
2.如果这个key不存在，那么线程创建key，成功则获取到锁，该key就为存在状态。
3.如果该key已经存在，那么线程就不能创建key，则获取锁失败。




