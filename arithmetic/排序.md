## 归并排序

####  详解
归并排序是递归算法的一个很好的实例，他的基本操作是合并两个已排序的表。因为这两个表是已经排序的，所以若将输出放到第三个表中时，该算法可以通过对输入数据的一趟排序来完成。

对于一个数组，归并排序递归地将前半部分数据和后半部分数据各自进行归并排序，得到排序后的两部分数据，然后使用`合并`算法再将两部分合并到一起。例如

有一个数组 [1、2、23、4、38、15、13、24],归并排序
1. 首先拆分左右数组，将数组拆分成[1、2、23、4] [38、15、13、24]
2. 递归的对左右数组进行排序，得到排序后的两部分数组
3. 使用合并算法将两部分合并到一起


基本的合并算法是，取输入数组A，B，输出数组C，以及三个计数器Aptr，Bptr，Cptr，他们初始置于数组的开始端。
排序后的数组为 [1、2、4、23]    [13、15、24、38]   [ 、 、 、 、 、 、 、 ]
              Aptr             Bptr              Cptr

首先比较初始的1和13，1被加入到C中,然后将2与13进行比较
[1、2、4、23]  [13、15、24、38]   [1、 、 、 、 、 、 、 ]
    Aptr        Bptr                Cptr
2被加入到C中，连续进行比较直至A中元素全部加入到C中
[1、2、4、23]  [13、15、24、38]   [1、2、4 、13 、15 、23 、 、 ]
            Aptr       Bptr                              Cptr
将B中剩余元素全部copy进入C中。

可以看到，合并两个表的时间显然是线性的，因为最多进行了N-1次比较。归并排序是经典的`分治`策略，它是将问题分解为一些小问题然后递归求解，而治的阶段则将
分的阶段得到的解进行合并。

#### 例程
```

//归并排序
func MergeSort(A []int) {
	//分配额外空间
	N := len(A)
	tmp := make([]int, N)
	if tmp != nil {
		MSort(A, tmp, 0, N-1)
	} else {
		errors.New("No space for tmp array!")
	}

}

func MSort(A []int, tmp []int, Left int, Right int) {
	var Center int
	if Left < Right {
		//拆分左右数组 递归进行排序
		Center = (Left + Right) / 2
		MSort(A, tmp, Left, Center)
		MSort(A, tmp, Center+1, Right)
		//合并左右数组
		Merge(A, tmp, Left, Center+1, Right)
	}
}

func Merge(A []int, TmpArray []int, Lptr int, Rptr int, REnd int) {
	LEnd := Rptr - 1
	TmpPos := Lptr
	NumElements := REnd - Lptr + 1

	//从开始端进行比较，并非放入额外数组中
	for Lptr <= LEnd && Rptr <= REnd {
		if A[Lptr] <= A[Rptr] {
			TmpArray[TmpPos] = A[Lptr]
			TmpPos++
			Lptr++
		} else {
			TmpArray[TmpPos] = A[Rptr]
			TmpPos++
			Rptr++
		}
	}
	//将剩余数组元素进行复制填满额外数组
	for Lptr <= LEnd {
		TmpArray[TmpPos] = A[Lptr]
		TmpPos++
		Lptr++
	}
	//
	for Rptr <= REnd {
		TmpArray[TmpPos] = A[Rptr]
		TmpPos++
		Rptr++
	}

	//
	for i := 0; i < NumElements; i, REnd = i+1, REnd-1 {
		A[REnd] = TmpArray[REnd]
	}
}

```

#### 时间复杂度分析

假设N是2的幂，这样我们在递归时总能将它分裂成均为偶数的两部分。
对于N=1，归并排序所用时间是常数，对N不为1的数进行归并排序，其用时等于完成两个大小为N/2的递归排序所用时间加上合并的时间，由此得出

1. T(1) = 1
2. T(N)=2T(N/2)+N

一种方法是通过*叠缩*,这里我们采用递归带入
对2式进行带入，令N=N/2
```                    T(N/2)=2(T(N/4))+N/2 
                    2T(N/2)=2(2(T(N/4))+N/2)  //两边同时乘2
					       =4T(N/4)+N
```
得到    
3. T(N)=4T(N/4)+2N
继续对2式进行迭代 令N=N/4 并同时乘4
```
                      4T(N/4)=4(2T(N/8)+N/4)=8T(N/8)+N
				带入3式  得到T(N)=8T(N/8)+3N
```
继续迭代 可以得到

                `T(N)=2^kT(N/2^k)+k*N`
利用k=log N 可得到
             `T(N)=NT(1)+N log N=Nlog N+N`
这里我们是分析N=2^k,如果不能分解得到偶数数组，其实得到答案也是一样的，也就是说归并排序是一种*稳定排序*，其时间复杂度为O(N logN),空间复杂度为O(N)